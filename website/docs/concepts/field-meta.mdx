---
sidebar_position: 2
---

# Field meta

Field meta describes **how a field has been interacted with**, not whether its value is valid.

Formora intentionally separates **interaction state** from **validation** so that UI behavior remains predictable and under your control.

---

## What is field meta?

Field meta answers questions like:

- Has the user interacted with this field?
- Has its value changed from the initial value?

It does **not** answer:

- Is the value correct?
- Should an error be shown?

Those decisions belong to **validation** and **UI logic**, not meta state.

---

## Available meta state

Formora exposes two pieces of field meta:

- `touched`
- `dirty`

Both follow the same **nested shape** as `values` and `errors`.

---

## `touched`

`touched` becomes `true` when a field **loses focus** (`blur`).

This means:

- the user has interacted with the field
- the field was focused at least once

```tsx
<input {...form.register("email")} />;

{
  form.touched?.email && <span>Field was touched</span>;
}
```

:::info
A touched field is **not necessarily invalid**.
:::

---

## `dirty`

`dirty` indicates whether the current value differs from `initialValues`.

Important characteristics:

- value-based comparison (not event-based)
- works with nested paths (`profile.email`)
- works with arrays (`items.0.name`)

```tsx
<input {...form.register("email")} />;

{
  form.dirty?.email && <span>Value was modified</span>;
}
```

---

## Error visibility vs validation

Formora separates responsibilities:

| Concern            | Controlled by                                   |
| ------------------ | ----------------------------------------------- |
| What is invalid    | validation rules (`required`, `validate`, etc.) |
| When to show error | **your UI logic**                               |

Formora exposes:

- `errors` — what is invalid
- `touched` / `dirty` — how the user interacted

You decide when errors are visible.

### Common patterns

#### Show errors after blur (recommended for `blur` mode)

```tsx
<input {...form.register("email", { required: "Email is required" })} />;

{
  form.touched?.email && form.errors?.email && (
    <p>{String(form.errors.email)}</p>
  );
}
```

#### Show errors immediately (live feedback)

```tsx
{
  form.errors?.email && <p>{String(form.errors.email)}</p>;
}
```

---

## What Formora does NOT track

To keep behavior predictable, Formora does **not** track:

- async validation state
- per-field loading state
- automatic error visibility rules

These are application-level concerns.

---

## Summary

- `touched` tells you if a field was interacted with
- `dirty` tells you if a value changed from its initial value
- Meta state does not imply validity
- You control when and how errors are shown

This explicit separation avoids hidden UX rules and makes complex forms easier to reason about.
